<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Predictor v18 - Enhanced & Fixed</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: #0f172a; min-height: 100vh; padding: 20px; color: #e2e8f0; }
        .container { max-width: 1800px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 30px; }
        .logo { font-size: 56px; margin-bottom: 15px; background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 20px rgba(245, 158, 11, 0.3)); animation: float 3s ease-in-out infinite; }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        h1 { font-size: 48px; font-weight: 800; background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px; letter-spacing: -2px; }
        .version { color: #94a3b8; font-size: 14px; font-weight: 500; }
        .badge { display: inline-block; padding: 6px 12px; border-radius: 20px; font-size: 10px; font-weight: 700; margin-left: 8px; animation: pulse-glow 2s infinite; }
        .ai-badge { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; text-transform: uppercase; letter-spacing: 1px; }
        .fixed-badge { background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; text-transform: uppercase; letter-spacing: 1px; }
        @keyframes pulse-glow { 0%, 100% { box-shadow: 0 0 10px rgba(245, 158, 11, 0.3); } 50% { box-shadow: 0 0 20px rgba(245, 158, 11, 0.6); } }
        .main-grid { display: grid; grid-template-columns: 1.5fr 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .card { background: rgba(30, 41, 59, 0.5); backdrop-filter: blur(20px); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 20px; padding: 25px; transition: all 0.3s ease; }
        .card:hover { border-color: rgba(245, 158, 11, 0.3); transform: translateY(-2px); }
        .ai-panel { background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(124, 58, 237, 0.1) 100%); border: 2px solid rgba(139, 92, 246, 0.3); }
        .trading-panel { background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.1) 100%); border: 2px solid rgba(16, 185, 129, 0.3); }
        .section-title { font-size: 14px; font-weight: 700; color: #e2e8f0; margin-bottom: 18px; display: flex; align-items: center; gap: 8px; }
        .training-progress { width: 100%; height: 8px; background: rgba(30, 41, 59, 0.5); border-radius: 10px; overflow: hidden; margin: 15px 0; }
        .training-fill { height: 100%; background: linear-gradient(90deg, #8b5cf6 0%, #7c3aed 100%); transition: width 0.3s ease; }
        .input-group { margin-bottom: 15px; }
        .input-label { font-size: 11px; color: #94a3b8; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 1px; font-weight: 600; }
        .input-field { width: 100%; padding: 12px; background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 10px; color: #e2e8f0; font-size: 16px; font-weight: 600; transition: all 0.3s ease; }
        .input-field:focus { outline: none; border-color: #10b981; box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1); }
        .leverage-selector { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 10px; }
        .leverage-btn { padding: 8px; background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #94a3b8; font-size: 12px; font-weight: 700; cursor: pointer; transition: all 0.3s ease; }
        .leverage-btn:hover { border-color: #10b981; color: #10b981; }
        .leverage-btn.active { background: linear-gradient(135deg, #10b981 0%, #059669 100%); border-color: #10b981; color: white; }
        .trade-btn { padding: 16px; border: none; border-radius: 12px; font-weight: 800; font-size: 16px; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; width: 100%; margin-top: 15px; }
        .trade-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3); }
        .trade-btn.start { background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; }
        .trade-btn.stop { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; }
        .trade-btn.train { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white; }
        .trade-btn.import { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; margin-top: 10px; }
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-top: 15px; }
        .stat-box { background: rgba(30, 41, 59, 0.3); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 12px; padding: 15px; text-align: center; }
        .stat-label { font-size: 10px; color: #64748b; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .stat-value { font-size: 24px; font-weight: 800; }
        .stat-positive { color: #10b981; }
        .stat-negative { color: #ef4444; }
        .stat-neutral { color: #f59e0b; }
        .live-position { background: rgba(245, 158, 11, 0.1); border: 2px solid rgba(245, 158, 11, 0.3); border-radius: 16px; padding: 20px; margin-top: 15px; animation: pulse-border 2s infinite; }
        @keyframes pulse-border { 0%, 100% { border-color: rgba(245, 158, 11, 0.3); } 50% { border-color: rgba(245, 158, 11, 0.6); } }
        .position-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .position-type { font-size: 18px; font-weight: 800; text-transform: uppercase; }
        .position-type.long { color: #10b981; }
        .position-type.short { color: #ef4444; }
        .position-stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .position-stat { background: rgba(30, 41, 59, 0.3); border-radius: 10px; padding: 10px; }
        .position-stat-label { font-size: 9px; color: #64748b; margin-bottom: 5px; text-transform: uppercase; }
        .position-stat-value { font-size: 16px; font-weight: 700; }
        .price-section { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .price-card { background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(249, 115, 22, 0.1) 100%); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 16px; padding: 25px; text-align: center; position: relative; overflow: hidden; }
        .price-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 3px; background: linear-gradient(90deg, #f59e0b 0%, #f97316 100%); }
        .price-label { font-size: 11px; text-transform: uppercase; letter-spacing: 2px; color: #94a3b8; font-weight: 600; margin-bottom: 12px; }
        .price-value { font-size: 36px; font-weight: 800; color: #f59e0b; margin-bottom: 8px; }
        .pulse { width: 8px; height: 8px; background: #10b981; border-radius: 50%; display: inline-block; margin-left: 8px; animation: pulse 2s infinite; box-shadow: 0 0 10px #10b981; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        .chart-card { height: 400px; }
        .chart-container { position: relative; height: calc(100% - 45px); }
        .trade-log { max-height: 400px; overflow-y: auto; }
        .trade-entry { background: rgba(30, 41, 59, 0.3); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 10px; padding: 12px; margin-bottom: 10px; font-size: 12px; }
        .trade-entry.profit { border-left: 3px solid #10b981; }
        .trade-entry.loss { border-left: 3px solid #ef4444; }
        .controls { display: flex; gap: 12px; justify-content: center; margin-top: 20px; flex-wrap: wrap; }
        .btn { padding: 12px 24px; border: none; border-radius: 10px; font-weight: 700; font-size: 13px; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.5px; }
        .btn:hover { transform: translateY(-2px); }
        .btn-export { background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; }
        .btn-reset { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; }
        .loading { text-align: center; padding: 100px 20px; }
        .spinner { border: 4px solid rgba(245, 158, 11, 0.1); border-top: 4px solid #f59e0b; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .file-input { display: none; }
        @media (max-width: 1400px) { .main-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">₿</div>
            <h1>BTC Predictor v18<span class="ai-badge">🧠 IMPROVED</span><span class="fixed-badge">✅ FIXED</span></h1>
            <div class="version">Enhanced LSTM • Smart Trading • Trailing Stops • Import Data</div>
        </div>
        <div id="loading" class="loading"><div class="spinner"></div><p style="color: #64748b;">Initializing Enhanced System...</p></div>
        <div id="content" style="display: none;">
            <div class="main-grid">
                <div style="display: flex; flex-direction: column; gap: 20px;">
                    <div class="price-section">
                        <div class="price-card"><div class="price-label">Current Price<span class="pulse"></span></div><div class="price-value" id="currentPrice">$--</div><div style="font-size: 11px; color: #64748b; margin-top: 8px;" id="lastUpdate">--</div><div class="badge" style="background: rgba(245,158,11,0.2); color: #f59e0b; border: 1px solid rgba(245,158,11,0.3);">⚡ PYTH</div></div>
                        <div class="price-card"><div class="price-label">AI Prediction (15min)</div><div class="price-value" id="predictedPrice">$--</div><div style="font-size: 18px; font-weight: 700; margin-top: 10px;" id="direction">--</div><div style="font-size: 11px; color: #64748b; margin-top: 8px;" id="confidenceText">Confidence: --</div></div>
                    </div>
                    <div class="card ai-panel">
                        <div class="section-title">🧠 AI Model Status</div>
                        <div style="text-align: center;">
                            <div style="font-size: 14px; font-weight: 700; color: #8b5cf6; margin-bottom: 10px;" id="modelStatus">Collecting data...</div>
                            <div class="training-progress"><div class="training-fill" id="trainingProgress" style="width: 0%"></div></div>
                            <div style="font-size: 11px; color: #64748b;" id="trainingInfo">Need 200 data points for training</div>
                            <button id="trainBtn" class="trade-btn train" style="display: none;">🚀 Train AI Model</button>
                        </div>
                        <div class="stats-grid">
                            <div class="stat-box"><div class="stat-label">Accuracy</div><div class="stat-value stat-neutral" id="accuracy">--%</div></div>
                            <div class="stat-box"><div class="stat-label">Predictions</div><div class="stat-value stat-neutral" id="totalPredictions">0</div></div>
                            <div class="stat-box"><div class="stat-label">Data Points</div><div class="stat-value stat-neutral" id="dataPoints">0</div></div>
                            <div class="stat-box"><div class="stat-label">Retrains</div><div class="stat-value stat-neutral" id="retrainCount">0</div></div>
                        </div>
                    </div>
                    <div class="card chart-card"><div class="section-title">📈 Price & Prediction Chart</div><div class="chart-container"><canvas id="predictionChart"></canvas></div></div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 20px;">
                    <div class="card trading-panel">
                        <div class="section-title">💰 Trading Control</div>
                        <div class="input-group"><div class="input-label">Starting Balance ($)</div><input type="number" id="tradeAmount" class="input-field" value="1000" min="10" step="10"></div>
                        <div class="input-group"><div class="input-label">Leverage</div><div class="leverage-selector">
                            <button class="leverage-btn" data-lev="1">1x</button><button class="leverage-btn" data-lev="2">2x</button><button class="leverage-btn active" data-lev="5">5x</button><button class="leverage-btn" data-lev="10">10x</button>
                        </div></div>
                        <div class="input-group"><div class="input-label">Stop Loss (%)</div><input type="number" id="stopLoss" class="input-field" value="2" min="0.5" max="10" step="0.5"></div>
                        <div class="input-group"><div class="input-label">Trailing Stop (%)</div><input type="number" id="trailingStop" class="input-field" value="1.5" min="0.5" max="5" step="0.5"></div>
                        <button id="startTrading" class="trade-btn start">🚀 Start AI Trading</button>
                        <button id="stopTrading" class="trade-btn stop" style="display: none;">⏹️ Stop Trading</button>
                        <input type="file" id="importFile" class="file-input" accept=".json">
                        <button id="importBtn" class="trade-btn import">📁 Import Old Data</button>
                        <div class="stats-grid">
                            <div class="stat-box"><div class="stat-label">Balance</div><div class="stat-value stat-neutral" id="currentBalance">$1000.00</div></div>
                            <div class="stat-box"><div class="stat-label">Net P&L</div><div class="stat-value stat-neutral" id="netPnL">$0.00</div></div>
                            <div class="stat-box"><div class="stat-label">Wins</div><div class="stat-value stat-positive" id="winCount">0</div></div>
                            <div class="stat-box"><div class="stat-label">Losses</div><div class="stat-value stat-negative" id="lossCount">0</div></div>
                        </div>
                    </div>
                    <div class="card" id="livePositionCard" style="display: none;">
                        <div class="section-title">🔥 Live Position</div>
                        <div class="live-position">
                            <div class="position-header">
                                <div class="position-type" id="posType">LONG</div>
                                <div style="font-size: 14px; font-weight: 700; color: #f59e0b;" id="posLeverage">5x</div>
                            </div>
                            <div class="position-stats">
                                <div class="position-stat"><div class="position-stat-label">Entry</div><div class="position-stat-value" id="posEntry">$--</div></div>
                                <div class="position-stat"><div class="position-stat-label">Current</div><div class="position-stat-value" id="posCurrent">$--</div></div>
                                <div class="position-stat"><div class="position-stat-label">Live P&L</div><div class="position-stat-value" id="posLivePnL">$0.00</div></div>
                                <div class="position-stat"><div class="position-stat-label">P&L %</div><div class="position-stat-value" id="posLivePnLPercent">0.00%</div></div>
                                <div class="position-stat"><div class="position-stat-label">Stop Loss</div><div class="position-stat-value" id="posStopLoss">$--</div></div>
                                <div class="position-stat"><div class="position-stat-label">Trail Stop</div><div class="position-stat-value" id="posTrailStop">$--</div></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 20px;">
                    <div class="card"><div class="section-title">📋 Trade History</div><div class="trade-log" id="tradeLog"><div style="text-align: center; color: #64748b; padding: 20px;">No trades yet.</div></div></div>
                </div>
            </div>
            <div class="controls">
                <button id="exportBtn" class="btn btn-export">📥 Export Data</button>
                <button id="resetBtn" class="btn btn-reset">🔄 Reset All</button>
            </div>
        </div>
    </div>
    <script>
        // Constants - IMPROVED VALUES
        const PYTH_BTC_ID = '0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43';
        const PYTH_API_URL = 'https://hermes.pyth.network/api/latest_price_feeds';
        const UPDATE_INTERVAL = 10000;
        const PREDICTION_WINDOW = 15;
        const MIN_DATA_FOR_TRAINING = 200;
        const MIN_CONFIDENCE_TO_TRADE = 60;
        const RETRAIN_INTERVAL = 4 * 60 * 60 * 1000;
        const MIN_PREDICTIONS_FOR_RETRAIN = 20;
        
        // State Variables
        let history = [];
        let predictions = [];
        let evaluatedPredictions = [];
        let chartData = { labels: [], actual: [], predicted: [] };
        let chart = null;
        let isTrading = false;
        let startingBalance = 1000;
        let currentBalance = 1000;
        let leverage = 5;
        let stopLossPercent = 2;
        let trailingStopPercent = 1.5;
        let position = null;
        let winCount = 0;
        let lossCount = 0;
        let trades = [];
        let aiModel = null;
        let modelTrained = false;
        let isTraining = false;
        let retrainCount = 0;
        let lastRetrainTime = null;
        let predictionsSinceRetrain = 0;
        
        // Leverage Selector
        document.querySelectorAll('.leverage-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.leverage-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                leverage = parseInt(btn.dataset.lev);
            });
        });
        
        // Trading Controls
        document.getElementById('startTrading').addEventListener('click', startTrading);
        document.getElementById('stopTrading').addEventListener('click', stopTrading);
        document.getElementById('trainBtn').addEventListener('click', () => trainAIModel(true));
        document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
        document.getElementById('importFile').addEventListener('change', importData);
        
        function startTrading() {
            if (!modelTrained) {
                alert('⚠️ AI model not trained yet! Please wait for training to complete.');
                return;
            }
            startingBalance = parseFloat(document.getElementById('tradeAmount').value) || 1000;
            currentBalance = startingBalance;
            stopLossPercent = parseFloat(document.getElementById('stopLoss').value) || 2;
            trailingStopPercent = parseFloat(document.getElementById('trailingStop').value) || 1.5;
            isTrading = true;
            winCount = 0;
            lossCount = 0;
            trades = [];
            document.getElementById('startTrading').style.display = 'none';
            document.getElementById('stopTrading').style.display = 'block';
            document.getElementById('tradeAmount').disabled = true;
            document.getElementById('stopLoss').disabled = true;
            document.getElementById('trailingStop').disabled = true;
            updateTradingUI();
        }
        
        function stopTrading() {
            if (position) closePosition('Manual Stop');
            isTrading = false;
            document.getElementById('startTrading').style.display = 'block';
            document.getElementById('stopTrading').style.display = 'none';
            document.getElementById('tradeAmount').disabled = false;
            document.getElementById('stopLoss').disabled = false;
            document.getElementById('trailingStop').disabled = false;
            document.getElementById('livePositionCard').style.display = 'none';
        }
        
        function openPosition(type, entry) {
            if (currentBalance <= 0) return;
            const tradeAmount = currentBalance * 0.95;
            const stopLoss = type === 'long' 
                ? entry * (1 - stopLossPercent / 100)
                : entry * (1 + stopLossPercent / 100);
            
            position = {
                type,
                entry,
                amount: tradeAmount,
                leverage,
                time: new Date(),
                stopLoss,
                trailingStop: null,
                highestPrice: entry,
                lowestPrice: entry
            };
            updateLivePosition();
        }
        
        function closePosition(reason, exitPrice = null) {
            if (!position) return;
            
            const currentPrice = exitPrice || history[history.length - 1];
            const priceChange = (currentPrice - position.entry) / position.entry;
            const multiplier = position.type === 'long' ? 1 : -1;
            const pnlPercent = priceChange * multiplier * position.leverage;
            const pnl = position.amount * pnlPercent;
            
            currentBalance += pnl;
            
            const trade = {
                type: position.type,
                entry: position.entry,
                exit: currentPrice,
                leverage: position.leverage,
                pnl,
                pnlPercent: pnlPercent * 100,
                reason,
                time: position.time,
                closeTime: new Date()
            };
            
            if (pnl > 0) {
                winCount++;
            } else {
                lossCount++;
            }
            
            trades.unshift(trade);
            if (trades.length > 50) trades.pop();
            
            position = null;
            document.getElementById('livePositionCard').style.display = 'none';
            updateTradingUI();
            updateTradeLog();
        }
        
        function updateTrailingStop(currentPrice) {
            if (!position) return;
            
            if (position.type === 'long') {
                if (currentPrice > position.highestPrice) {
                    position.highestPrice = currentPrice;
                    const newTrailStop = currentPrice * (1 - trailingStopPercent / 100);
                    if (newTrailStop > position.stopLoss) {
                        position.trailingStop = newTrailStop;
                    }
                }
            } else {
                if (currentPrice < position.lowestPrice) {
                    position.lowestPrice = currentPrice;
                    const newTrailStop = currentPrice * (1 + trailingStopPercent / 100);
                    if (newTrailStop < position.stopLoss) {
                        position.trailingStop = newTrailStop;
                    }
                }
            }
        }
        
        function checkStopLoss(currentPrice) {
            if (!position) return;
            
            const activeStop = position.trailingStop || position.stopLoss;
            
            if (position.type === 'long' && currentPrice <= activeStop) {
                closePosition('Stop Loss Hit', activeStop);
            } else if (position.type === 'short' && currentPrice >= activeStop) {
                closePosition('Stop Loss Hit', activeStop);
            }
        }
        
        function updateLivePosition() {
            if (!position || !isTrading) {
                document.getElementById('livePositionCard').style.display = 'none';
                return;
            }
            
            document.getElementById('livePositionCard').style.display = 'block';
            const currentPrice = history[history.length - 1];
            
            const priceChange = (currentPrice - position.entry) / position.entry;
            const multiplier = position.type === 'long' ? 1 : -1;
            const pnlPercent = priceChange * multiplier * position.leverage;
            const livePnL = position.amount * pnlPercent;
            
            document.getElementById('posType').textContent = position.type.toUpperCase();
            document.getElementById('posType').className = 'position-type ' + position.type;
            document.getElementById('posLeverage').textContent = position.leverage + 'x';
            document.getElementById('posEntry').textContent = '$' + position.entry.toLocaleString('en-US', {minimumFractionDigits: 2});
            document.getElementById('posCurrent').textContent = '$' + currentPrice.toLocaleString('en-US', {minimumFractionDigits: 2});
            document.getElementById('posLivePnL').textContent = (livePnL >= 0 ? '+' : '') + '$' + livePnL.toFixed(2);
            document.getElementById('posLivePnL').style.color = livePnL >= 0 ? '#10b981' : '#ef4444';
            document.getElementById('posLivePnLPercent').textContent = (pnlPercent * 100 >= 0 ? '+' : '') + (pnlPercent * 100).toFixed(2) + '%';
            document.getElementById('posLivePnLPercent').style.color = pnlPercent >= 0 ? '#10b981' : '#ef4444';
            
            const activeStop = position.trailingStop || position.stopLoss;
            document.getElementById('posStopLoss').textContent = '$' + position.stopLoss.toLocaleString('en-US', {minimumFractionDigits: 2});
            document.getElementById('posTrailStop').textContent = position.trailingStop 
                ? '$' + position.trailingStop.toLocaleString('en-US', {minimumFractionDigits: 2})
                : 'Not Set';
        }
        
        function updateTradingUI() {
            const netPnL = currentBalance - startingBalance;
            document.getElementById('currentBalance').textContent = '$' + currentBalance.toFixed(2);
            document.getElementById('currentBalance').className = 'stat-value ' + 
                (currentBalance > startingBalance ? 'stat-positive' : currentBalance < startingBalance ? 'stat-negative' : 'stat-neutral');
            document.getElementById('netPnL').textContent = (netPnL >= 0 ? '+' : '') + '$' + netPnL.toFixed(2);
            document.getElementById('netPnL').className = 'stat-value ' + (netPnL >= 0 ? 'stat-positive' : 'stat-negative');
            document.getElementById('winCount').textContent = winCount;
            document.getElementById('lossCount').textContent = lossCount;
        }
        
        function updateTradeLog() {
            if (trades.length === 0) {
                document.getElementById('tradeLog').innerHTML = '<div style="text-align: center; color: #64748b; padding: 20px;">No trades yet.</div>';
                return;
            }
            
            const html = trades.map(t => {
                const pnlClass = t.pnl > 0 ? 'profit' : 'loss';
                const emoji = t.pnl > 0 ? '✅' : '❌';
                
                let closeTimeStr;
                try {
                    if (t.closeTime instanceof Date) {
                        closeTimeStr = t.closeTime.toLocaleTimeString();
                    } else if (typeof t.closeTime === 'string') {
                        closeTimeStr = new Date(t.closeTime).toLocaleTimeString();
                    } else {
                        closeTimeStr = new Date().toLocaleTimeString();
                    }
                } catch (e) {
                    closeTimeStr = 'Unknown time';
                }
                
                return `<div class="trade-entry ${pnlClass}">
                    <div style="display:flex;justify-content:space-between;margin-bottom:5px;">
                        <span style="font-weight:700;">${emoji} ${t.type.toUpperCase()} ${t.leverage}x</span>
                        <span style="font-weight:700;color:${t.pnl>=0?'#10b981':'#ef4444'};">${t.pnl>=0?'+':''}$${t.pnl.toFixed(2)}</span>
                    </div>
                    <div style="font-size:11px;color:#64748b;">Entry: $${t.entry.toFixed(2)} → Exit: $${t.exit.toFixed(2)} (${t.pnlPercent>=0?'+':''}${t.pnlPercent.toFixed(2)}%)</div>
                    <div style="font-size:10px;color:#475569;margin-top:3px;">${t.reason} • ${closeTimeStr}</div>
                </div>`;
            }).join('');
            
            document.getElementById('tradeLog').innerHTML = html;
        }
        
        async function trainAIModel(isInitial = false) {
            if (isTraining || history.length < MIN_DATA_FOR_TRAINING) {
                if (!isInitial) {
                    console.log('⏭️ Skipping retrain - insufficient data or already training');
                    return;
                }
                alert(`Need ${MIN_DATA_FOR_TRAINING} data points. Currently have: ${history.length}`);
                return;
            }
            
            isTraining = true;
            document.getElementById('trainBtn').disabled = true;
            const statusPrefix = isInitial ? 'Initial training' : `Retraining (${retrainCount + 1})`;
            document.getElementById('modelStatus').textContent = statusPrefix + '...';
            
            console.log('🧠 ' + (isInitial ? 'Initial Training' : `Retrain #${retrainCount + 1}`));
            
            try {
                const trainingData = isInitial ? history : history.slice(-500);
                const data = normalizeData(trainingData);
                
                const seqLength = 20;
                const X = [];
                const y = [];
                
                for (let i = 0; i <= data.length - seqLength - 1; i++) {
                    const seq = [];
                    for (let j = 0; j < seqLength; j++) {
                        seq.push([data[i + j]]);
                    }
                    X.push(seq);
                    y.push([data[i + seqLength]]);
                }
                
                const xTensor = tf.tensor3d(X);
                const yTensor = tf.tensor2d(y);
                
                if (!aiModel || isInitial) {
                    aiModel = tf.sequential();
                    aiModel.add(tf.layers.lstm({
                        units: 128,
                        returnSequences: true,
                        inputShape: [seqLength, 1],
                        kernelRegularizer: tf.regularizers.l2({ l2: 0.001 })
                    }));
                    aiModel.add(tf.layers.dropout({ rate: 0.3 }));
                    aiModel.add(tf.layers.lstm({
                        units: 64,
                        returnSequences: false,
                        kernelRegularizer: tf.regularizers.l2({ l2: 0.001 })
                    }));
                    aiModel.add(tf.layers.dropout({ rate: 0.2 }));
                    aiModel.add(tf.layers.dense({ units: 32, activation: 'relu' }));
                    aiModel.add(tf.layers.dense({ units: 1 }));
                    
                    aiModel.compile({
                        optimizer: tf.train.adam(0.001),
                        loss: 'meanSquaredError',
                        metrics: ['mae']
                    });
                }
                
                const epochs = isInitial ? 80 : 40;
                
                await aiModel.fit(xTensor, yTensor, {
                    epochs: epochs,
                    batchSize: 32,
                    validationSplit: 0.2,
                    shuffle: true,
                    callbacks: {
                        onEpochEnd: (epoch, logs) => {
                            const progress = ((epoch + 1) / epochs) * 100;
                            document.getElementById('trainingProgress').style.width = progress + '%';
                            document.getElementById('trainingInfo').textContent = 
                                `${statusPrefix} - Epoch ${epoch + 1}/${epochs} - Loss: ${logs.loss.toFixed(4)}`;
                        }
                    },
                    verbose: 0
                });
                
                xTensor.dispose();
                yTensor.dispose();
                
                modelTrained = true;
                retrainCount++;
                lastRetrainTime = Date.now();
                predictionsSinceRetrain = 0;
                
                const statusMsg = isInitial 
                    ? '✅ Enhanced AI Trained Successfully!'
                    : `🔄 Retrained! (Cycle #${retrainCount})`;
                
                document.getElementById('modelStatus').textContent = statusMsg;
                document.getElementById('trainingInfo').textContent = `Ready • ${X.length} sequences trained`;
                document.getElementById('retrainCount').textContent = retrainCount;
                
                console.log('✅ Training complete:', X.length, 'sequences');
                
            } catch (error) {
                console.error('❌ Training error:', error);
                document.getElementById('modelStatus').textContent = '❌ Training Failed';
                document.getElementById('trainingInfo').textContent = 'Error: ' + error.message;
                if (isInitial) alert('Training failed: ' + error.message);
            } finally {
                isTraining = false;
                document.getElementById('trainBtn').disabled = false;
            }
        }
        
        function shouldRetrain() {
            if (!modelTrained) return false;
            
            if (lastRetrainTime && (Date.now() - lastRetrainTime >= RETRAIN_INTERVAL)) {
                console.log('🔄 Scheduled retrain (4 hours passed)');
                return true;
            }
            
            if (predictionsSinceRetrain >= MIN_PREDICTIONS_FOR_RETRAIN) {
                console.log('🔄 Retrain after', predictionsSinceRetrain, 'predictions');
                return true;
            }
            
            return false;
        }
        
        function normalizeData(data) {
            const mean = data.reduce((a, b) => a + b, 0) / data.length;
            const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length;
            const std = Math.sqrt(variance) + 0.0001;
            return data.map(val => (val - mean) / std);
        }
        
        function denormalizeData(normalizedVal, originalData) {
            const mean = originalData.reduce((a, b) => a + b, 0) / originalData.length;
            const variance = originalData.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / originalData.length;
            const std = Math.sqrt(variance);
            return (normalizedVal * std) + mean;
        }
        
        async function predictWithAI(currentPrice) {
            if (!aiModel || !modelTrained || history.length < 20) return null;
            
            try {
                const recentData = history.slice(-200);
                const normalizedHistory = normalizeData(recentData);
                
                const seqLength = 20;
                const sequence = [];
                for (let i = 0; i < seqLength; i++) {
                    sequence.push([normalizedHistory[normalizedHistory.length - seqLength + i]]);
                }
                
                const inputTensor = tf.tensor3d([sequence]);
                const prediction = aiModel.predict(inputTensor);
                const normalizedPred = await prediction.data();
                
                inputTensor.dispose();
                prediction.dispose();
                
                const predictedPrice = denormalizeData(normalizedPred[0], recentData);
                const confidence = calculateConfidence(predictedPrice, currentPrice, recentData);
                
                predictionsSinceRetrain++;
                
                if (shouldRetrain()) {
                    setTimeout(() => trainAIModel(false), 2000);
                }
                
                return {
                    price: predictedPrice,
                    direction: predictedPrice > currentPrice ? 'UP ⬆️' : 'DOWN ⬇️',
                    confidence: confidence,
                    timestamp: Date.now(),
                    targetTime: Date.now() + (PREDICTION_WINDOW * 60 * 1000)
                };
                
            } catch (error) {
                console.error('❌ Prediction error:', error);
                return null;
            }
        }
        
        function calculateConfidence(predicted, current, recentData) {
            const percentDiff = Math.abs((predicted - current) / current) * 100;
            
            const prices = recentData.slice(-30);
            const changes = [];
            for (let i = 1; i < prices.length; i++) {
                changes.push(Math.abs((prices[i] - prices[i-1]) / prices[i-1]) * 100);
            }
            const avgVolatility = changes.reduce((a, b) => a + b, 0) / changes.length;
            
            let confidence = 50;
            
            if (percentDiff > avgVolatility * 0.5 && percentDiff < avgVolatility * 2.5) {
                confidence = 75;
            } else if (percentDiff > avgVolatility * 0.3 && percentDiff < avgVolatility * 3) {
                confidence = 68;
            } else if (percentDiff > avgVolatility * 0.1) {
                confidence = 60;
            }
            
            if (percentDiff > 0.3) confidence += 5;
            if (percentDiff > 0.6) confidence += 5;
            
            return Math.min(Math.max(confidence, 45), 85);
        }
        
        function initChart() {
            const ctx = document.getElementById('predictionChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'Actual Price',
                        data: chartData.actual,
                        borderColor: '#f59e0b',
                        backgroundColor: 'rgba(245,158,11,0.05)',
                        borderWidth: 3,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 6
                    }, {
                        label: '15min Prediction',
                        data: chartData.predicted,
                        borderColor: '#8b5cf6',
                        backgroundColor: 'rgba(139,92,246,0.05)',
                        borderWidth: 3,
                        borderDash: [8, 4],
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: {
                            labels: { color: '#94a3b8', font: { size: 12, weight: 700 }, padding: 15 },
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(15,23,42,0.95)',
                            titleColor: '#f59e0b',
                            bodyColor: '#e2e8f0',
                            borderColor: 'rgba(245,158,11,0.3)',
                            borderWidth: 1,
                            padding: 12
                        }
                    },
                    scales: {
                        x: { ticks: { color: '#64748b', font: { size: 10 } } },
                        y: { ticks: { color: '#64748b', font: { size: 11 } } }
                    }
                }
            });
        }
        
        function updateChart(actual, predicted) {
            const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            chartData.labels.push(time);
            chartData.actual.push(actual);
            chartData.predicted.push(predicted || actual);
            
            if (chartData.labels.length > 30) {
                chartData.labels.shift();
                chartData.actual.shift();
                chartData.predicted.shift();
            }
            
            if (chart) {
                try {
                    chart.update('none');
                } catch (e) {
                    console.error('Chart update error:', e);
                }
            }
        }
        
        function evaluatePredictions(currentPrice) {
            const now = Date.now();
            const windowMs = PREDICTION_WINDOW * 60 * 1000;
            
            predictions = predictions.filter(pred => {
                if (now - pred.timestamp >= windowMs) {
                    const actualDir = currentPrice > pred.currentPrice ? 'up' : 'down';
                    const predDir = pred.price > pred.currentPrice ? 'up' : 'down';
                    const correct = actualDir === predDir;
                    
                    evaluatedPredictions.push({
                        correct,
                        timestamp: pred.timestamp,
                        confidence: pred.confidence
                    });
                    
                    if (evaluatedPredictions.length > 100) evaluatedPredictions.shift();
                    return false;
                }
                return true;
            });
        }
        
        async function fetchBTCPrice() {
            const response = await fetch(`${PYTH_API_URL}?ids[]=${PYTH_BTC_ID}`);
            const data = await response.json();
            if (data && data[0] && data[0].price) {
                const p = data[0].price;
                return {
                    price: parseFloat(p.price) * Math.pow(10, p.expo),
                    timestamp: Date.now()
                };
            }
            throw new Error('Invalid response');
        }
        
        async function update() {
            try {
                const priceData = await fetchBTCPrice();
                if (priceData && priceData.price) {
                    const price = priceData.price;
                    history.push(price);
                    if (history.length > 2000) history.shift();
                    
                    evaluatePredictions(price);
                    
                    let prediction = null;
                    if (modelTrained) {
                        prediction = await predictWithAI(price);
                        if (prediction) {
                            predictions.push({ ...prediction, currentPrice: price });
                        }
                    }
                    
                    updateUI(priceData, prediction);
                    
                    if (isTrading && currentBalance > 0) {
                        if (position) {
                            updateTrailingStop(price);
                            checkStopLoss(price);
                            updateLivePosition();
                            
                            if (prediction && prediction.confidence >= MIN_CONFIDENCE_TO_TRADE) {
                                const shouldClose = 
                                    (position.type === 'long' && prediction.direction.includes('DOWN')) ||
                                    (position.type === 'short' && prediction.direction.includes('UP'));
                                
                                if (shouldClose) {
                                    closePosition('AI Signal Change', price);
                                    const newType = prediction.direction.includes('UP') ? 'long' : 'short';
                                    if (currentBalance > 0) openPosition(newType, price);
                                }
                            }
                        } else {
                            if (prediction && prediction.confidence >= MIN_CONFIDENCE_TO_TRADE) {
                                const type = prediction.direction.includes('UP') ? 'long' : 'short';
                                openPosition(type, price);
                            }
                        }
                    }
                    
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('content').style.display = 'block';
                    
                    if (history.length >= MIN_DATA_FOR_TRAINING && !modelTrained && !isTraining) {
                        const shouldAsk = localStorage.getItem('btc-v18-train-asked');
                        if (!shouldAsk) {
                            localStorage.setItem('btc-v18-train-asked', 'true');
                            setTimeout(() => {
                                if (confirm(`🧠 AI Model Ready!\n\n${history.length} data points collected.\n\nStart training now?`)) {
                                    trainAIModel(true);
                                }
                            }, 3000);
                        }
                    }
                }
            } catch (error) {
                console.error('❌ Update error:', error);
            }
        }
        
        function updateUI(priceData, prediction) {
            const price = priceData.price;
            document.getElementById('currentPrice').textContent = `$${price.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
            document.getElementById('lastUpdate').textContent = `Updated: ${new Date().toLocaleTimeString()}`;
            document.getElementById('dataPoints').textContent = history.length;
            
            updateChart(price, prediction ? prediction.price : null);
            
            if (prediction) {
                document.getElementById('predictedPrice').textContent = 
                    `$${prediction.price.toLocaleString('en-US', {minimumFractionDigits: 2})}`;
                document.getElementById('direction').textContent = prediction.direction;
                document.getElementById('direction').style.color = 
                    prediction.direction.includes('UP') ? '#10b981' : '#ef4444';
                document.getElementById('confidenceText').textContent = 
                    `Confidence: ${prediction.confidence.toFixed(0)}%`;
            }
            
            const correct = evaluatedPredictions.filter(p => p.correct).length;
            const total = evaluatedPredictions.length;
            const accuracy = total > 0 ? (correct / total * 100) : 0;
            
            document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';
            document.getElementById('totalPredictions').textContent = total;
            
            const dataProgress = (history.length / MIN_DATA_FOR_TRAINING) * 100;
            document.getElementById('trainingProgress').style.width = Math.min(dataProgress, 100) + '%';
            
            if (modelTrained) {
                document.getElementById('modelStatus').textContent = '✅ AI Model Active';
                document.getElementById('trainingInfo').textContent = 
                    `${retrainCount} retrains • ${predictionsSinceRetrain} predictions since last retrain`;
            } else if (history.length >= MIN_DATA_FOR_TRAINING && !isTraining) {
                document.getElementById('trainBtn').style.display = 'block';
                document.getElementById('modelStatus').textContent = '✅ Ready for Training';
                document.getElementById('trainingInfo').textContent = `${history.length} points - Click to train`;
            } else if (history.length < MIN_DATA_FOR_TRAINING) {
                document.getElementById('modelStatus').textContent = 
                    `Collecting... (${history.length}/${MIN_DATA_FOR_TRAINING})`;
                document.getElementById('trainingInfo').textContent = 'Gathering data for training...';
            }
        }
        
        async function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                if (data.history && Array.isArray(data.history)) {
                    history = data.history;
                    console.log('✅ Imported', history.length, 'price history points');
                }
                
                if (data.trades && Array.isArray(data.trades)) {
                    trades = data.trades.slice(0, 50).map(trade => {
                        if (trade.time && typeof trade.time === 'string') {
                            trade.time = new Date(trade.time);
                        }
                        if (trade.closeTime && typeof trade.closeTime === 'string') {
                            trade.closeTime = new Date(trade.closeTime);
                        }
                        return trade;
                    });
                    updateTradeLog();
                    console.log('✅ Imported', trades.length, 'trades');
                }
                
                if (data.trading) {
                    if (data.trading.winCount !== undefined) winCount = data.trading.winCount;
                    if (data.trading.liqCount !== undefined) lossCount = data.trading.liqCount;
                    if (data.trading.lossCount !== undefined) lossCount = data.trading.lossCount;
                }
                
                if (data.evaluatedPredictions && Array.isArray(data.evaluatedPredictions)) {
                    evaluatedPredictions = data.evaluatedPredictions.slice(-100);
                    console.log('✅ Imported', evaluatedPredictions.length, 'evaluated predictions');
                }
                
                if (data.aiStatus) {
                    if (data.aiStatus.retrainCount !== undefined) {
                        retrainCount = data.aiStatus.retrainCount;
                        document.getElementById('retrainCount').textContent = retrainCount;
                    }
                }
                
                alert(`✅ Data imported successfully!\n\n• ${history.length} price points\n• ${trades.length} trades\n• ${evaluatedPredictions.length} predictions\n• ${retrainCount} retrain cycles`);
                
                updateTradingUI();
                
                const correct = evaluatedPredictions.filter(p => p.correct).length;
                const total = evaluatedPredictions.length;
                const accuracy = total > 0 ? (correct / total * 100) : 0;
                document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';
                document.getElementById('totalPredictions').textContent = total;
                
                document.getElementById('importFile').value = '';
                
            } catch (error) {
                console.error('❌ Import error:', error);
                alert('❌ Failed to import data: ' + error.message);
            }
        }
        
        function exportData() {
            const correct = evaluatedPredictions.filter(p => p.correct).length;
            const total = evaluatedPredictions.length;
            
            const data = {
                metadata: {
                    version: "18.0 Enhanced & Fixed",
                    exportDate: new Date().toISOString()
                },
                history,
                predictions,
                evaluatedPredictions,
                trades,
                trading: {
                    currentBalance,
                    startingBalance,
                    winCount,
                    lossCount,
                    leverage
                },
                aiStatus: {
                    trained: modelTrained,
                    dataPoints: history.length,
                    retrainCount,
                    lastRetrainTime
                },
                performance: {
                    total,
                    correct,
                    accuracy: total > 0 ? (correct / total * 100).toFixed(2) + '%' : '0%'
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `btc-v18-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function resetAll() {
            if (confirm('⚠️ Reset everything?\n\nThis will delete:\n• All data\n• AI model\n• Trading history\n• Predictions\n\nContinue?')) {
                history = [];
                predictions = [];
                evaluatedPredictions = [];
                chartData = { labels: [], actual: [], predicted: [] };
                trades = [];
                winCount = 0;
                lossCount = 0;
                currentBalance = startingBalance;
                retrainCount = 0;
                lastRetrainTime = null;
                predictionsSinceRetrain = 0;
                
                if (aiModel) {
                    aiModel.dispose();
                    aiModel = null;
                }
                modelTrained = false;
                
                localStorage.removeItem('btc-v18');
                localStorage.removeItem('btc-v18-train-asked');
                
                setTimeout(() => location.reload(), 500);
            }
        }
        
        document.getElementById('exportBtn').addEventListener('click', exportData);
        document.getElementById('resetBtn').addEventListener('click', resetAll);
        
        setTimeout(() => {
            if (document.getElementById('content').style.display !== 'none') {
                try {
                    initChart();
                } catch (e) {
                    console.error('Chart init error:', e);
                    setTimeout(() => initChart(), 1000);
                }
            }
        }, 500);
        
        update();
        setInterval(update, UPDATE_INTERVAL);
    </script>
</body>
</html>
